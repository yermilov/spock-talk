= What Mr. Spock would possibly say about modern unit testing: pragmatic and emotional overview
Yaroslav Yermilov <https://github.com/yermilov[icon:github[] @yermilov] https://twitter.com/yermilov17[icon:twitter[] @yermilov17] https://www.facebook.com/yaroslav.yermilov[icon:facebook[] @yaroslav.yermilov]>
2016 June 23
:toc:
:icons: font
:linkattrs:
:source-highlighter: coderay
:sourcedir: ../../

== Original Talk

This is a textual version of link:http://jeeconf.com/program/what-mr-spock-would-possibly-say-about-modern-unit-testing-pragmatic-and-emotional-overview/[the talk given at JEEConf 2016, window="_blank"].

Recorded talk:

video::3nSXDEj7sKM[youtube, width=560, height=315, opts="allowfullscreen"]

Slides from the talk:

pass:[<iframe src="http://www.slideshare.net/slideshow/embed_code/key/ehE5vzQ7yu5map" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>]

== Code Examples

All code examples can be found link:https://github.com/yermilov/spock-talk[at GitHub, window="_blank"].

== About Me

I have 5 year experience working in the Java world starting from Intern in EPAM Systems to Senior Software Engineer today in the same company.
Most of this time I've worked in Big Data area, developing various extensions for Hadoop-family tools. Almost accidentally, 2 years ago I became responsible for automated testing on my project.
Out of work, I'm inspired by Groovy ecosystem and data science.

== What's About Modern Unit Testing?

To my mind, automated testing is one of the most powerful software development concept suggested so far.
After receiving great attention as part of XP manifesto, it made possible to increase size of projects and complexity of code we are able to maintain by orders of magnitude.

link:http://junit.org/[JUnit, window="_blank"], started by Kent Beck and Erich Gamma, played key role in the development of the automated testing idea as it was one of the first ever and surely the most popular and influential automated testing library.

link:http://testng.org/[TestNG, window="_blank"], started by CÃ©dric Beust, was inspired by JUnit and initiated to offer wider and more powerful range of functionalities than JUnit originally does, keeping the same general concept. Later, most of the TestNG initiatives were implemented by JUnit.

As link:http://blog.takipi.com/the-top-100-java-libraries-in-2016-after-analyzing-47251-dependencies/[recent study, window="_blank"] shows, JUnit is used by about amazingly 60% of Java projects and TestNG shows quite strong result of about 6%.

.Source: http://blog.takipi.com/the-top-100-java-libraries-in-2016-after-analyzing-47251-dependencies/
image::images\spock-11ca2.png[]

Both JUnit and TestNG shares the same framework architecture often called xUnit (surprisingly after SUnit and JUnit itself).
It's described best by two concepts: test structure and assertions. As test structure obviously is set of features to describe tests organization, and assertion is a function that verifies the behavior (or the state) of the unit under test.
If we look at the most simple JUnit and TestNG tests we will found them quite similarly implementing both concepts:

[source,java]
.Easy JUnit start
----
include::{sourcedir}/test/java/N01J_EasyStart.java[tags=easyJUnit]
----
<1> Test structure
<2> Assertion

[source,java]
.Easy TestNG start
----
include::{sourcedir}/test/java/N02T_EasyStart.java[tags=easyTestNG]
----
<1> Test structure
<2> Assertion

Actually, except for import statements, these code snippets are the same.
My feel is that, not arguing with all benefits of JUnit and TestNG, they both were frozen long time ago and no longer evolving.
Since 2013, there were 0 (zero!) major releases of traditional test frameworks. All we have for the last 3 years is one JUnit 4.12 release and several TestNG 6.9 releases. Actually, Spock is the only one, having epochal 1.0 release recently.

image::images\spock-10799.png[]

Offering great functionality in this moment, JUnit and TestNG are at risk of missing latest software engineering requests and trends.
However, JUnit is ready to overcome this problem with 5.0 release, scheduled for this year.

Anyway, there are several possibilities for passionate developers to continue evolving their test automation instruments. Let's examine them shortly.

=== JUnit 5

We can just wait until traditional tools will attempt to make revolutionary changes. Sounds not very promising, but sometimes miracles happen. link:http://junit.org/junit5/[JUnit 5, window="_blank"] is on the way to final release after link:https://www.indiegogo.com/projects/junit-lambda#/[very successful crowdfunding campaign on Indiegogo, window="_blank"].

For now we can only examine alpha releases, but we already can see that after a great work of JUnit team we will get a fresh new look at how JUnit should be implemented.
The most significant change is introduction of solid testing backend model, but it's not a main topic of this article.
Let's check how the simpliest JUnit 5 test looks like. How many changes you can see?

[source,java]
.Easy JUnit 5 start
----
include::{sourcedir}/test/java/N03_J5_EasyStartTest.java[tags=easyJUnit5]
----
<1> Worked in May 2016. It's alpha, so I bet it's now working already.
<2> Test structure
<3> Assertion
<4> Changes!

=== Testing on Steroids

We can use one of plenty libraries that boost test code quality: link:http://hamcrest.org/JavaHamcrest/[Hamcrest, window="_blank"] (used by ~4% Java projects), link:http://joel-costigliola.github.io/assertj/[AssertJ, window="_blank"] (used by ~3% Java projects), link:http://google.github.io/truth/[Google Truth, window="_blank"] for assertions; link:http://mockito.org/[Mockito, window="_blank"] (used by ~10% Java projects), link:https://github.com/jayway/powermock[PowerMock, window="_blank"] (used by ~1.5% Java projects), link:http://jmockit.org/[JMockit, window="_blank"], link:http://easymock.org/[EasyMock, window="_blank"] (used by ~3% Java projects) for mocking and stubbing and probably some others like link:https://github.com/spring-projects/spring-framework/tree/master/spring-test[Spring Test, window="_blank"] (used by ~6% Java projects).

Actually I hope in the year 2016, no one is writing tests that looks like ones I've already shown.
As a base rule, they should be at least two steps forward: test should have clear inner structure and assertion should clearly explain its intent:

[source,java]
.Easy, but idiomatic JUnit start
----
include::{sourcedir}/test/java/N01J_EasyStart.java[tags=idiomaticJUnit]
----
<1> Outer test structure
<2> Inner test structure
<3> Assertion

=== Spock

Finally, we can make really big step forward and try completely new testing approach - link:http://docs.spockframework.org/[Spock, window="_blank"] - test framework developed by Peter Niederwleser and Luke Daley.
As big steps are much more effective when they are done immediately, here is a very simple Spock test.
If you write tests that looks like the last example, it will be very simple for you to get what is going on there:

[source,groovy]
.Easy Spock start
----
include::{sourcedir}/test/groovy/N04S_EasyStart.groovy[tags=easySpock]
----
<1> Outer test structure
<2> Inner test structure
<3> Assertion

== Why Try Spock?

Why someone should try to use Spock on their projects? In the following sections I will demonstrate all benefits that can be gained from Spock usage.
Additionally, I will show drawbacks of such decision.
But despite both pros and cons there are two reasons why everyone should try Spock at least for their pet projects and later evaluate if it will be useful for the real ones:

* *Spock is the next generation test framework*. What does it mean? Spock takes all the years of automated testing experience and pain and re-imagine how it should be implemented if we look at it from a different angle.
_What if_ we do not need to use the same language for testing as we use for production code?
_What if_ it can be language designed for testing specifically?
_What if_ test context can be moved from comments to code?
_What if_ there are different testing approaches and we should offer convenient features for all of them?
Spock asks plenty of _What if?_ questions and the main answer is that most of test features are already well-known, but if we forget their current implementations, they can be re-implemented in a better way.

* *Spock is enterprise ready*. Spock is more than 6 years old. Spock is already released 1.0 version and has stable API.
It's completely mature framework that can be safely used without any fears.

== How To Start With Spock?

As you can already see, it's more than easy to start using Spock.
Begin with adding these three dependencies to your project:

[source,groovy]
----
'org.spockframework:spock-core:1.0-groovy-2.4'
'cglib:cglib-nodep:3.1'
'org.objenesis:objenesis:2.1'
----

If you already have test code you want to migrate to Spock either from JUnit of TestNG take there five easy steps:

. Rename your test files from `\*.java` to `*.groovy` and move them to `src/test/groovy` directory.
. Extend your test class form `spock.lang.Specification` class.
. Remove all `@Test` annotations and change return type for all test methods to `def`.
. Enforce inner test structure by using following labels: `setup` for test object setting up, `when` for test actions and `then` for assertions.
. Enjoy becoming a Spock developer in less than 15 minutes.

== Spock Assertions

However, if you are starting from scratch, you will probably want to write more idiomatic Spock code.
The first step towards this goal is start using Spock assertions.

In the first place, each test framework offers two simple assertion constructions: `assertEquals` checks for equality of two objects and `assertTrue` checks if specified expression is true. However, using such constructions has two critical drawbacks:

* when test fails, it's hard to understand why it has failed;
* test code is not maintainable, as it's not obvious what was the intent behind each assertion.

Just try to look at following test failure logs and guess what is tested and why tests have failed:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertEqualsTrue]
----

That's why it is so important to use external assertion library.
The most popular one, Hamcrest, clearly shows intent behind assertion both in the test code and in the failure message:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertHamcrest]
----

Two libraries that are less popular, AssertJ and Google Truth, shows not only the assertion intent but also describe some part of the test context that lead to the failure:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertjTruth]
----

Original Spock assertions show a little intent behind their code, but they are not less than perfect in demonstrating test context that lead to the failure. Moreover, all you need to start using them is to place boolean expression inside `then` block:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertSpock]
----

Just look how useful they are when we need to examine some complex data flow:

image::images\spock-4f14e.png[]

But in combination with well-known Hamcrest matchers, Spock assertions provide 100% needed information from both test code and test failure reports:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=expectSpock]
----

Spock assertions were so successful that they were ported to plain Groovy, which means that if you use JUnit or TestNG you can write you code in Groovy, immediatelly getting Spock assertions in your old-fashioned tests:

[source,groovy]
----
include::{sourcedir}/test/groovy/N06J_PowerAsserts.groovy[tags=assertGroovy]
----

== Test structure

As it was already mentioned, the second main part of every testing framework is test structure toolset.
Traditional approach is pretty much the same:

[source,groovy]
.JUnit test structure toolset
----
include::{sourcedir}/test/groovy/N08J_SetupTeardown.groovy[tags=structureJUnit]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

[source,groovy]
.TestNG test structure toolset
----
include::{sourcedir}/test/groovy/N09T_SetupTeardown.groovy[tags=structureTestNG]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

[source,groovy]
.JUnit 5 test structure toolset
----
include::{sourcedir}/test/groovy/N10J5_SetupTeardown.groovy[tags=structureJUnit5]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

Here is one important thing about Spock philosophy as project. *If you do like traditional approach you can continue using it. Spock will just add some fancy Groovy magic to make it better*. In this concrete case, you can use link:http://docs.groovy-lang.org/next/html/documentation/core-traits.html[Groovy traits, window="_blank"] to extract repeatable setup/cleanup behavior and reuse it easily across your test classes:

[source,groovy]
.Spock reusable test structure via traits
----
include::{sourcedir}/test/groovy/DatabaseSpec.groovy[]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Executed after each test case
<5> Executed once after all test cases

To inject this behavior to your test specification, just implement all traits you need:

[source,groovy]
.Spock test structure toolset
----
include::{sourcedir}/test/groovy/N11S_SetupTeardown_AsYouLike.groovy[tags=structureSpock]
----

And here is one more important thing about Spock philosophy as project. *Spock always offers more!* Let's examine the following:

[source,groovy]
.Spock more test structure toolset
----
include::{sourcedir}/test/groovy/N12S_SetupTeardown_AndMore.groovy[tags=structureSpock]
----
<1> Instead of using `static` keyword for shared resources use `@Shared` annotation
<2> `@AutoCleanup` annotation invokes close method of the shared resource after each test case
<3> Tests can have individual setup blocks
<4> Tests can have individual cleanup blocks

Let's look at `@Shared` annotation closely. It will demonstrate why it's so important to use test-specific language for your tests instead of general purpose language like Java.
When you develop your test (but not only test) code, each time you try to find language feature that suites best your need.
For example, if you need to share some resource within test class and you use Java, natural choice will be `static`.
But, what if you want to do the same in several test classes? You can extract this behavior to superclass like following:

[source,groovy]
.`static` field for resource sharing
----
include::{sourcedir}/test/groovy/N14S_SharedExplained.groovy[tags=staticForSharing]
----

If you look carefully, you will find that some of these tests will fail.
Single resource will be shared between all three test cases and you have no control over it.

Spock, as test-specific language, can keep in mind needs of test code developers and offer features that gives you more control on test code behavior.
In this example `@Shared` annotation clearly will share resource only within single specification. Our example is fixed:

[source,groovy]
.`@Shared` field for resource sharing
----
include::{sourcedir}/test/groovy/N14S_SharedExplained.groovy[tags=sharedForSharing]
----

== Other Features

== Why Use Spock?

== Why Do Not Use Spock?

== When Use Spock?
