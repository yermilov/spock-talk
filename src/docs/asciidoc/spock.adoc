= What Mr. Spock would possibly say about modern unit testing: pragmatic and emotional overview
Yaroslav Yermilov <https://github.com/yermilov[icon:github[] @yermilov] https://twitter.com/yermilov17[icon:twitter[] @yermilov17] https://www.facebook.com/yaroslav.yermilov[icon:facebook[] @yaroslav.yermilov]>
2016 June 23
:toc:
:icons: font
:linkattrs:
:source-highlighter: coderay
:sourcedir: ../../

== Original Talk

This is a textual version of link:http://jeeconf.com/program/what-mr-spock-would-possibly-say-about-modern-unit-testing-pragmatic-and-emotional-overview/[the talk given at JEEConf 2016, window="_blank"].

Recorded talk:

video::3nSXDEj7sKM[youtube, width=560, height=315, opts="allowfullscreen"]

Slides from the talk:

pass:[<iframe src="http://www.slideshare.net/slideshow/embed_code/key/ehE5vzQ7yu5map" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>]

== Code Examples

All code examples can be found link:https://github.com/yermilov/spock-talk[at GitHub, window="_blank"].

== About Me

I have 5 year experience working in the Java world starting from Intern in EPAM Systems to Senior Software Engineer today in the same company.
Most of this time I've worked in Big Data area, developing various extensions for Hadoop-family tools. Almost accidentally, 2 years ago I became responsible for automated testing on my project.
Out of work, I'm inspired by Groovy ecosystem and data science.

== What's About Modern Unit Testing?

To my mind, automated testing is one of the most powerful software development concept suggested so far.
After receiving great attention as part of XP manifesto, it made possible to increase size of projects and complexity of code we are able to maintain by orders of magnitude.

link:http://junit.org/[JUnit, window="_blank"], started by Kent Beck and Erich Gamma, played key role in the development of the automated testing idea as it was one of the first ever and surely the most popular and influential automated testing library.

link:http://testng.org/[TestNG, window="_blank"], started by CÃ©dric Beust, was inspired by JUnit and initiated to offer wider and more powerful range of functionalities than JUnit originally does, keeping the same general concept. Later, most of the TestNG initiatives were implemented by JUnit.

As link:http://blog.takipi.com/the-top-100-java-libraries-in-2016-after-analyzing-47251-dependencies/[recent study, window="_blank"] shows, JUnit is used by about amazingly 60% of Java projects and TestNG shows quite strong result of about 6%.

.Source: http://blog.takipi.com/the-top-100-java-libraries-in-2016-after-analyzing-47251-dependencies/
image::images\spock-11ca2.png[]

Both JUnit and TestNG shares the same framework architecture often called xUnit (surprisingly after SUnit and JUnit itself).
It's described best by two concepts: test structure and assertions. As test structure obviously is set of features to describe tests organization, and assertion is a function that verifies the behavior (or the state) of the unit under test.
If we look at the most simple JUnit and TestNG tests we will found them quite similarly implementing both concepts:

[source,java]
.Easy JUnit start
----
include::{sourcedir}/test/java/N01J_EasyStart.java[tags=easyJUnit]
----
<1> Test structure
<2> Assertion

[source,java]
.Easy TestNG start
----
include::{sourcedir}/test/java/N02T_EasyStart.java[tags=easyTestNG]
----
<1> Test structure
<2> Assertion

Actually, except for import statements, these code snippets are the same.
My feel is that, not arguing with all benefits of JUnit and TestNG, they both were frozen long time ago and no longer evolving.
Since 2013, there were 0 (zero!) major releases of traditional test frameworks. All we have for the last 3 years is one JUnit 4.12 release and several TestNG 6.9 releases. Actually, Spock is the only one, having epochal 1.0 release recently.

image::images\spock-10799.png[]

Offering great functionality in this moment, JUnit and TestNG are at risk of missing latest software engineering requests and trends.
However, JUnit is ready to overcome this problem with 5.0 release, scheduled for this year.

Anyway, there are several possibilities for passionate developers to continue evolving their test automation instruments. Let's examine them shortly.

=== JUnit 5

We can just wait until traditional tools will attempt to make revolutionary changes. Sounds not very promising, but sometimes miracles happen. link:http://junit.org/junit5/[JUnit 5, window="_blank"] is on the way to final release after link:https://www.indiegogo.com/projects/junit-lambda#/[very successful crowdfunding campaign on Indiegogo, window="_blank"].

For now we can only examine alpha releases, but we already can see that after a great work of JUnit team we will get a fresh new look at how JUnit should be implemented.
The most significant change is introduction of solid testing backend model, but it's not a main topic of this article.
Let's check how the simpliest JUnit 5 test looks like. How many changes you can see?

[source,java]
.Easy JUnit 5 start
----
include::{sourcedir}/test/java/N03_J5_EasyStartTest.java[tags=easyJUnit5]
----
<1> Worked in May 2016. It's alpha, so I bet it's now working already.
<2> Test structure
<3> Assertion
<4> Changes!

=== Testing on Steroids

We can use one of plenty libraries that boost test code quality: link:http://hamcrest.org/JavaHamcrest/[Hamcrest, window="_blank"] (used by ~4% Java projects), link:http://joel-costigliola.github.io/assertj/[AssertJ, window="_blank"] (used by ~3% Java projects), link:http://google.github.io/truth/[Google Truth, window="_blank"] for assertions; link:http://mockito.org/[Mockito, window="_blank"] (used by ~10% Java projects), link:https://github.com/jayway/powermock[PowerMock, window="_blank"] (used by ~1.5% Java projects), link:http://jmockit.org/[JMockit, window="_blank"], link:http://easymock.org/[EasyMock, window="_blank"] (used by ~3% Java projects) for mocking and stubbing and probably some others like link:https://github.com/spring-projects/spring-framework/tree/master/spring-test[Spring Test, window="_blank"] (used by ~6% Java projects).

Actually I hope in the year 2016, no one is writing tests that looks like ones I've already shown.
As a base rule, they should be at least two steps forward: test should have clear inner structure and assertion should clearly explain its intent:

[source,java]
.Easy, but idiomatic JUnit start
----
include::{sourcedir}/test/java/N01J_EasyStart.java[tags=idiomaticJUnit]
----
<1> Outer test structure
<2> Inner test structure
<3> Assertion

=== Spock

Finally, we can make really big step forward and try completely new testing approach - link:http://docs.spockframework.org/[Spock, window="_blank"] - test framework developed by Peter Niederwleser and Luke Daley.
As big steps are much more effective when they are done immediately, here is a very simple Spock test.
If you write tests that looks like the last example, it will be very simple for you to get what is going on there:

[source,groovy]
.Easy Spock start
----
include::{sourcedir}/test/groovy/N04S_EasyStart.groovy[tags=easySpock]
----
<1> Outer test structure
<2> Inner test structure
<3> Assertion

== Why Try Spock?

Why someone should try to use Spock on their projects? In the following sections I will demonstrate all benefits that can be gained from Spock usage.
Additionally, I will show drawbacks of such decision.
But despite both pros and cons there are two reasons why everyone should try Spock at least for their pet projects and later evaluate if it will be useful for the real ones:

* *Spock is the next generation test framework*. What does it mean? Spock takes all the years of automated testing experience and pain and re-imagine how it should be implemented if we look at it from a different angle.
_What if_ we do not need to use the same language for testing as we use for production code?
_What if_ it can be language designed for testing specifically?
_What if_ test context can be moved from comments to code?
_What if_ there are different testing approaches and we should offer convenient features for all of them?
Spock asks plenty of _What if?_ questions and the main answer is that most of test features are already well-known, but if we forget their current implementations, they can be re-implemented in a better way.

* *Spock is enterprise ready*. Spock is more than 6 years old. Spock is already released 1.0 version and has stable API.
It's completely mature framework that can be safely used without any fears.

== How To Start With Spock?

As you can already see, it's more than easy to start using Spock.
Begin with adding these three dependencies to your project:

[source,groovy]
----
'org.spockframework:spock-core:1.0-groovy-2.4'
'cglib:cglib-nodep:3.1'
'org.objenesis:objenesis:2.1'
----

If you already have test code you want to migrate to Spock either from JUnit of TestNG take there five easy steps:

. Rename your test files from `\*.java` to `*.groovy` and move them to `src/test/groovy` directory.
. Extend your test class form `spock.lang.Specification` class.
. Remove all `@Test` annotations and change return type for all test methods to `def`.
. Enforce inner test structure by using following labels: `setup` for test object setting up, `when` for test actions and `then` for assertions.
. Enjoy becoming a Spock developer in less than 15 minutes.

== Spock Assertions

However, if you are starting from scratch, you will probably want to write more idiomatic Spock code.
The first step towards this goal is start using Spock assertions.

In the first place, each test framework offers two simple assertion constructions: `assertEquals` checks for equality of two objects and `assertTrue` checks if specified expression is true. However, using such constructions has two critical drawbacks:

* when test fails, it's hard to understand why it has failed;
* test code is not maintainable, as it's not obvious what was the intent behind each assertion.

Just try to look at following test failure logs and guess what is tested and why tests have failed:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertEqualsTrue]
----

That's why it is so important to use external assertion library.
The most popular one, Hamcrest, clearly shows intent behind assertion both in the test code and in the failure message:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertHamcrest]
----

Two libraries that are less popular, AssertJ and Google Truth, shows not only the assertion intent but also describe some part of the test context that lead to the failure:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertjTruth]
----

Original Spock assertions show a little intent behind their code, but they are not less than perfect in demonstrating test context that lead to the failure. Moreover, all you need to start using them is to place boolean expression inside `then` block:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=assertSpock]
----

Just look how useful they are when we need to examine some complex data flow:

image::images\spock-4f14e.png[]

But in combination with well-known Hamcrest matchers, Spock assertions provide 100% needed information from both test code and test failure reports:

[source,groovy]
----
include::{sourcedir}/test/groovy/N05S_Asserts.groovy[tags=expectSpock]
----

Spock assertions were so successful that they were ported to plain Groovy, which means that if you use JUnit or TestNG you can write you code in Groovy, immediatelly getting Spock assertions in your old-fashioned tests:

[source,groovy]
----
include::{sourcedir}/test/groovy/N06J_PowerAsserts.groovy[tags=assertGroovy]
----

== Test Structure

As it was already mentioned, the second main part of every testing framework is test structure toolset.
Traditional approach is pretty much the same:

[source,groovy]
.JUnit test structure toolset
----
include::{sourcedir}/test/groovy/N08J_SetupTeardown.groovy[tags=structureJUnit]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

[source,groovy]
.TestNG test structure toolset
----
include::{sourcedir}/test/groovy/N09T_SetupTeardown.groovy[tags=structureTestNG]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

[source,groovy]
.JUnit 5 test structure toolset
----
include::{sourcedir}/test/groovy/N10J5_SetupTeardown.groovy[tags=structureJUnit5]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Test case
<5> Executed after each test case
<6> Executed once after all test cases

Here is one important thing about Spock philosophy as project. *If you do like traditional approach you can continue using it. Spock will just add some fancy Groovy magic to make it better*. In this concrete case, you can use link:http://docs.groovy-lang.org/next/html/documentation/core-traits.html[Groovy traits, window="_blank"] to extract repeatable setup/cleanup behavior and reuse it easily across your test classes:

[source,groovy]
.Spock reusable test structure via traits
----
include::{sourcedir}/test/groovy/DatabaseSpec.groovy[]
----
<1> Shared resource
<2> Executed once before all test cases
<3> Executed before each test case
<4> Executed after each test case
<5> Executed once after all test cases

To inject this behavior to your test specification, just implement all traits you need:

[source,groovy]
.Spock test structure toolset
----
include::{sourcedir}/test/groovy/N11S_SetupTeardown_AsYouLike.groovy[tags=structureSpock]
----

And here is one more important thing about Spock philosophy as project. *Spock always offers more!* Let's examine the following:

[source,groovy]
.Spock more test structure toolset
----
include::{sourcedir}/test/groovy/N12S_SetupTeardown_AndMore.groovy[tags=structureSpock]
----
<1> Instead of using `static` keyword for shared resources use `@Shared` annotation
<2> `@AutoCleanup` annotation invokes close method of the shared resource after each test case
<3> Tests can have individual setup blocks
<4> Tests can have individual cleanup blocks

Let's look at `@Shared` annotation closely. It will demonstrate why it's so important to use test-specific language for your tests instead of general purpose language like Java.
When you develop your test (but not only test) code, each time you try to find language feature that suites best your need.
For example, if you need to share some resource within test class and you use Java, natural choice will be `static`.
But, what if you want to do the same in several test classes? You can extract this behavior to superclass like following:

[source,groovy]
.`static` field for resource sharing
----
include::{sourcedir}/test/groovy/N14S_SharedExplained.groovy[tags=staticForSharing]
----

If you look carefully, you will find that some of these tests will fail.
Single resource will be shared between all three test cases and you have no control over it.

Spock, as test-specific language, can keep in mind needs of test code developers and offer features that gives you more control on test code behavior.
In this example `@Shared` annotation clearly will share resource only within single specification. Our example is fixed:

[source,groovy]
.`@Shared` field for resource sharing
----
include::{sourcedir}/test/groovy/N14S_SharedExplained.groovy[tags=sharedForSharing]
----

== Inner Test Structure

To my mind, the most important Spock feature comparing to other test framework (that do not have anything similar) is *enforcing inner test structure*.
While it's generally a good practice to set up inner test structure using comments, Spock provides language features that make you do it.
It's really great design decision, because comments, as they are not natural part of the code, becomes outdated very quickly.
When something is part of the code, it is always up to date.
Let's look at the example:

[source,groovy]
.Spock inner test structure
----
include::{sourcedir}/test/groovy/N07S_IdiomaticSpock.groovy[]
----
<1> Title gives short name of what is going on within this test suite
<2> Narrative is the text describing specification
<3> Subject points on object under test
<4> Issue describes issues connected with the test case
<5> You are already familiar with `setup` block, but pay attention on string (not comment!) that follows each test block describing what is going on inside it
<6> `expect` block contains set of conditions that all should evaluate to `true`
<7> `when` block contains set of actions on object under test
<8> `and` block helps to split sets under `when` or `then` blocks
<9> `then` block contains set of conditions that all should evaluate to `true` after previous `when` block

Great follow-up from the fact that test structure becomes part of the test code is that this information becomes available at runtime.
Projects like link:https://github.com/renatoathaydes/spock-reports[Spock reports, window="_blank"] leverage this information and, for example, generate very detailed reports based on it.
Just look at test report that is ready to publish for your team non-development folks:

image::images\spock-f353a.png[]

All you need to do is add following code to your build file:

[source,groovy]
----
testCompile('com.athaydes:spock-reports:1.2.10') {
    transitive = false // this avoids affecting your version of Groovy/Spock
}
----

== Data Driven Tests

To my mind, while the previous feature is greatest and the most unappreciated Spock feature, this one is the most overvalued one.
Surely, it's very powerful, but it's needed only for some specific cases, while inner test structure is generally applicable.
I'm talking about data driven tests. Let's look at quick example:

[source,groovy]
.Complex data driven test
----
include::{sourcedir}/test/groovy/N15S_DataProviders.groovy[tags=complexTest]
----
<1> `where` is new test block used for defining variables that work as multiple test parameters for same test scenario
<2> Test parameter can be defined as collection of values
<3> Or just as assignment rule
<4> Defined test parameters can be used as regular variables inside other test blocks

This example shows _complex_ test case, when the same scenario is run against multiple test parameters within same equivalence class.
Test is considered as passed if and only if test scenario passes all test parameters.
Here is how test report looks for this case:

image::images\spock-1dd56.png[]

Another use case supported by Spock is reusing same test code for test cases from different equivalence class.
Here is example that demonstrate this and some other concepts:

[source,groovy]
.Dividual data driven test
----
include::{sourcedir}/test/groovy/N15S_DataProviders.groovy[tags=dividualTests]
----
<1> `@Unroll` annotation turns complex test case into dividual one
<2> test parameters can be used inside test name with `#` mark
<3> test parameters can be organized into fancy tables

This example shows _dividual_ test cases, when test representation is separated from test code.
Each test parameter generate individual test case, that is shares the same code, but not test result, with others.
Here is how test report looks for this case:

image::images\spock-997c6.png[]

Traditional test frameworks mix up both concepts, and moreover provide very poor language support for data-driven test:

[source,java]
.JUnit data driven test
----
include::{sourcedir}/test/java/N16J_DataProviders.java[tags=dataDriven]
----
image::images\spock-b408e.png[]

[source,java]
.TestNG data driven test
----
include::{sourcedir}/test/java/N17T_DataProviders.java[tags=dataDriven]
----
image::images\spock-25dc5.png[]

Pay attention that using `Object[][]` is very unsafe and unclear for test parameters set up, and even more, that TestNG does not supports test naming easily.

== Exceptions Handling

When you want to have a test case checking that exception is thrown for some particular test case in your JUnit test suite, it is as easy as defining simple `@Test` parameter:

[source,java]
.JUnit simple thrown exception check
----
include::{sourcedir}/test/java/N19J_Exceptions.java[tags=simpleExpectException]
----

Thing become a little harder when you need to perform some additional checks, like exception message or stack trace:

[source,java]
.JUnit simple thrown exception message check
----
include::{sourcedir}/test/java/N19J_Exceptions.java[tags=simpleExceptionMessage]
----

For both cases, Spock comes for a very convenient way to catch thrown exception and do whatever you want to do with and check whatever you want to check:

[source,groovy]
.Spock thrown exception check
----
include::{sourcedir}/test/groovy/N18S_Exceptions.groovy[tags=expectException]
----

But what if you want to check that after some action exception was _not_ thrown?
The most simple way is just do nothing, as unexpected exception will cause test to fail:

[source,java]
.JUnit simple not-thrown exception check
----
include::{sourcedir}/test/java/N19J_Exceptions.java[tags=simpleNotExpectException]
----

The problem with such approach is that it exception is _do_ thrown test will be marked not as _failed_ but as _error_.
If you do not like it, you should do something like:

[source,java]
.JUnit ugly not-thrown exception check
----
include::{sourcedir}/test/java/N19J_Exceptions.java[tags=uglyNotExpectException]
----

What Spock do is, again, come up with very convenient way to declare that test intent is that exception should not be thrown.
Pay attention that it's done not through comment, but rather with language construction:

[source,groovy]
.Spock not-thrown exception check
----
include::{sourcedir}/test/groovy/N18S_Exceptions.groovy[tags=notExpectException]
----

If you are familiar with link:https://github.com/junit-team/junit4/wiki/Rules[JUnit Rules API, window="_blank"], you surely can come up with much better solution:

[source,java]
.JUnit thrown exception check via Rules API
----
include::{sourcedir}/test/java/N19J_Exceptions.java[tags=ruleException]
----

JUnit 5 can do the same natively:

[source,java]
.JUnit 5 thrown exception check
----
include::{sourcedir}/test/java/N21J5_Exceptions.java[tags=expectException]
----

What is very disappointing is that TestNG has a very limited, closed and ugly solution for the same problem.
If you want to check exception error message, you should supply expected regexp to `@Test` annotation:

[source,java]
.TestNG thrown exception check
----
include::{sourcedir}/test/java/N20T_Exceptions.java[tags=expectException]
----

== Other Features

== Why Use Spock?

== Why Do Not Use Spock?

== When Use Spock?
